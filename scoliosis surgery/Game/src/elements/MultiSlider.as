package src.elements{	import flash.display.MovieClip;	import com.greensock.*;	import com.greensock.easing.*;	import com.greensock.plugins.*;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.text.TextField;	import flash.geom.Point;	import src.GLP.GMGDebugger;	import src.game.GameLogic;	import flash.utils.getDefinitionByName;	import flash.display.DisplayObject;	import flash.media.SoundChannel;	import src.game.GMGSound;	import src.game.SoundManager;	TweenPlugin.activate([BezierPlugin]);		[Inspectable(name="points", variable="points", type="Array")]	[Inspectable(name="childToDrag", variable="childToDrag", type="String")]	[Inspectable(name="animationTotalFrames", variable="m_animationTotalFrames", type="Number")]	[Inspectable(name="bgSound", variable="bgSound", type="String")]		public class MultiSlider extends MovieClip	{		public var startMouseX;		//declare tween		public var tween:TweenMax;				private var m_timer:Timer = new Timer(1000/30);				private var m_mouseOver:Boolean = false;		private var m_dragging:Boolean = false;				private var m_distanceBetweenEachPoint:Array;		private var m_reachedPoints:Vector.<Boolean>;				private var m_totalDistance:Number = 0;				private var m_progress:Number = 0;				private var m_oldPoint:Point = new Point();				// Inspectable variables		private var m_points:Array;		public var m_childToDrag:MovieClip;		public var m_animationTotalFrames;				private var m_sound:GMGSound = null;		private var m_soundChannel:SoundChannel = null;		private var m_bgSound:String;		public function MultiSlider()		{			this.visible = false;			m_childToDrag = null;			m_timer.start();			m_timer.addEventListener(TimerEvent.TIMER, update);						m_points = new Array();			m_reachedPoints = new Vector.<Boolean>();			m_distanceBetweenEachPoint = new Array();		}				public function resetTween():void		{			if(m_childToDrag != null && m_points != null)			{				MovieClip(parent).stop();				var pointArray:Array = new Array();								var slideButton:MovieClip = m_childToDrag;								for(var i:int = 0, j:int = 0; i < m_points.length; i++)				{					var mcPoint:MovieClip = parent.getChildByName(m_points[i]) as MovieClip;					pointArray.push({x:mcPoint.x, y:mcPoint.y});					if(i > 0)					{						var mcLastPoint:MovieClip = parent.getChildByName(m_points[i - 1]) as MovieClip;						var distX:Number = (mcPoint.x - mcLastPoint.x);						var distY:Number = (mcPoint.y - mcLastPoint.y);						var dist:Number = Math.sqrt((distX*distX) + (distY*distY));						m_distanceBetweenEachPoint[j++] = dist;						m_totalDistance += dist;						m_reachedPoints.push(false);												if(i == 1) // The second point						{							m_childToDrag.rotation = Math.atan2(distY, distX)/Math.PI * 180;						}					}					else					{						m_distanceBetweenEachPoint[j++] = 0;						m_reachedPoints.push(true);						slideButton.x = mcPoint.x;						slideButton.y = mcPoint.y;						m_oldPoint.x = mcPoint.x;						m_oldPoint.y = mcPoint.y;					}				}								tween = TweenMax.to(slideButton, 4, {bezier:{values:pointArray,				  type:"thru",				  curviness:1				  },				  ease:Linear.easeNone,				  paused:true				  });					  				slideButton.buttonMode = true;				slideButton.addEventListener(MouseEvent.MOUSE_OUT, outHandler);				slideButton.addEventListener(MouseEvent.MOUSE_OVER, overHandler);				slideButton.addEventListener(MouseEvent.MOUSE_UP, upHandler);				slideButton.addEventListener(MouseEvent.MOUSE_DOWN, downHandler);			}		}				public function set points(array:Array):void		{			m_points = array;			resetTween();		}				public function get points():Array		{			return m_points;		}				public function set bgSound(string:String):void		{			m_bgSound = string;			try			{				var Def:Class = getDefinitionByName(string) as Class;				m_sound = new Def();			}			catch(err:Error)			{				GMGDebugger.traceString("Could not find sound named " + string + "at scene " + parent);			}		}				public function get bgSound():String		{			return m_bgSound;		}				public function set childToDrag(child:String):void		{			try			{				var Def:Class = getDefinitionByName(child) as Class;				m_childToDrag = new Def();				parent.addChild(m_childToDrag);			}			catch(error:*)			{				GMGDebugger.traceString("Couldn't find dragging object at scene " + GameLogic.sharedGameLogic().getCurrentSceneName());			}			resetTween();		}				public function get childToDrag():String		{			return m_childToDrag.name;		}				public function downHandler(e:MouseEvent):void		{			m_dragging = true;						if(m_sound != null)			{				if(m_soundChannel != null)				{					SoundManager.sharedManager().stopSound(m_soundChannel);					m_soundChannel = null;				}				m_soundChannel = SoundManager.sharedManager().playSound(m_sound, 9999);			}		}				public function upHandler(e:MouseEvent):void		{			m_dragging = false;						if(m_sound != null)			{				if(m_soundChannel != null)				{					SoundManager.sharedManager().stopSound(m_soundChannel);					m_soundChannel = null;				}			}		}				public function overHandler(e:MouseEvent):void		{			m_mouseOver = true;		}				public function outHandler(e:MouseEvent):void		{			m_mouseOver = false;		}				public function update(e:TimerEvent):void		{			var distX:Number, distY:Number, mouseDistX:Number, mouseDistY:Number, dist:Number, mouseDist:Number;			var i:int = getCurrentPoint();						if(m_dragging && m_mouseOver)			{				if(i != -1)				{					var currentPoint:MovieClip, nextPoint:MovieClip, dragChild:MovieClip;										currentPoint = parent.getChildByName(m_points[i - 1]) as MovieClip;					nextPoint = parent.getChildByName(m_points[i]) as MovieClip;					dragChild = m_childToDrag;										distX = (parent.mouseX - currentPoint.x);					distY = (parent.mouseY - currentPoint.y);					dist = Math.sqrt((distX*distX) + (distY*distY));										var newProgress:Number = (((getDistanceUntilPoint(i) + dist) * 100)/m_totalDistance)/100;										if(newProgress > m_progress)					{						tween.progress(newProgress);						m_progress = newProgress;					}										if(m_oldPoint.x != dragChild.x)					{						distX = dragChild.x - m_oldPoint.x;						distY = dragChild.y - m_oldPoint.y;						dragChild.rotation = Math.atan2(distY, distX)/Math.PI * 180;					}										if(nextPoint.hitTestObject(dragChild) && dist >= m_distanceBetweenEachPoint[i])					{						m_reachedPoints[i] = true;					}										m_oldPoint.x = dragChild.x;					m_oldPoint.y = dragChild.y;				}			}						var mcParent:MovieClip = parent as MovieClip;			if(mcParent.currentFrame < m_animationTotalFrames)			{				mcParent.gotoAndStop(getCurrentFrame());			}			else			{				mcParent.gotoAndPlay(m_animationTotalFrames);				m_dragging = false;				m_mouseOver = false;				parent.removeChild(m_childToDrag);				m_childToDrag = null;				m_timer.stop();				m_timer.removeEventListener(TimerEvent.TIMER, update);								if(m_sound != null)				{					if(m_soundChannel != null)					{						SoundManager.sharedManager().stopSound(m_soundChannel);						m_soundChannel = null;					}				}			}		}				public function getCurrentPoint():int		{			for(var i:int = 0; i < m_reachedPoints.length; i++)			{				if(!m_reachedPoints[i])				{					return i;				}			}			return -1;		}				public function getDistanceUntilPoint(pointIndex:int):Number		{			var distance:Number = 0;			for(var j:int = 0; j != pointIndex; j++)			{				distance += m_distanceBetweenEachPoint[j];			}			return distance;		}				public function getCurrentFrame():uint		{			return m_progress * m_animationTotalFrames;		}	}}